//SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

import "./interfaces/IERC2665.sol";
import "./interfaces/ITransferListener.sol";
import "./interfaces/IERC2665Handler.sol";

import "./extensions/HasSecondarySaleFee.sol";
import "./extensions/HasContractURI.sol";
import "./extensions/HasProxyRegistry.sol";
import "./extensions/HasCustomDefaultableCompositeTokenURI.sol";

import "./boringcrypto/BoringBatchable.sol";
import "./openzeppelin/ERC721Enumerable.sol";
import "./openzeppelin/ERC721Burnable.sol";

/**
 * @dev {ERC721} collection by Kyilkhor
 */
contract RaresamaCollectionV1 is
    Context,
    AccessControlEnumerable,
    ERC721Enumerable,
    ERC721Burnable,
    HasContractURI,
    HasCustomDefaultableCompositeTokenURI,
    HasSecondarySaleFee,
    HasProxyRegistry,
    BoringBatchable,
    IERC2665ForIERC721
{
    using Counters for Counters.Counter;

    uint256 public constant VERSION = 1;

    bytes32 public constant GOVERNANCE_ROLE = keccak256("GOVERNANCE_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant COMPOSITE_CREATOR_ROLE =
        keccak256("COMPOSITE_CREATOR_ROLE");

    Counters.Counter private _tokenIdTracker;

    ITransferListener public transferListener;
    IERC2665Handler public erc2665Handler;

    uint8 public decimals;
    bool public lockedForever;
    bool public initialized;

    event Lock(uint256 supply);

    constructor()
        ERC721("", "")
        HasContractURI("")
        HasCustomDefaultableCompositeTokenURI("")
        HasProxyRegistry(address(0))
    {}

    function initialize(
        address owner,
        address admin,
        address minter,
        string memory name,
        string memory symbol,
        uint8 _decimals,
        string memory _contractURI,
        string memory _defaultTokenURI,
        address _proxyRegistryAddress
    ) public virtual {
        require(!initialized, "RSC::initialize: already");

        // we start from index 1
        _tokenIdTracker.increment();

        _name = name;
        _symbol = symbol;
        decimals = _decimals;

        _setRoleAdmin(GOVERNANCE_ROLE, GOVERNANCE_ROLE);
        _setRoleAdmin(OPERATOR_ROLE, GOVERNANCE_ROLE);
        _setRoleAdmin(MINTER_ROLE, GOVERNANCE_ROLE);
        _setRoleAdmin(COMPOSITE_CREATOR_ROLE, GOVERNANCE_ROLE);

        _setupRole(GOVERNANCE_ROLE, owner);
        _setupRole(OPERATOR_ROLE, admin);
        _setupRole(MINTER_ROLE, minter);

        _setContractURI(_contractURI);
        _setDefaultTokenURI(_defaultTokenURI);
        _updateProxyRegistryAddress(_proxyRegistryAddress);

        initialized = true;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, string memory _customTokenURI) external virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "RSC::mint: unauthorized");
        require(!lockedForever, "RSC::mint: locked");

        uint256 _id = _tokenIdTracker.current();
        _tokenIdTracker.increment();
        _mint(to, _id);

        if (bytes(_customTokenURI).length > 0) {
            _setCustomTokenURI(_id, _customTokenURI);
        }
    }

    /**
     * @dev Mints with a placeholder as token URI
     */
    function mintDefault(address to) external virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "RSC::mint: unauthorized");
        require(!lockedForever, "RSC::mint: locked");

        uint256 _id = _tokenIdTracker.current();
        _tokenIdTracker.increment();
        _mint(to, _id);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        require(_exists(tokenId), "RSC::tokenURI: nonexistant");
        return _tokenURI(tokenId);
    }

    function originalURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "RSC::originalURI: nonexistant");
        return _originalURI(tokenId);
    }

    function compositeURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "RSC::compositeURI: nonexistant");
        return _compositeURI(tokenId);
    }

    function isApprovedForAll(address _owner, address _operator)
        public
        view
        virtual
        override(ERC721, IERC721)
        returns (bool)
    {
        // Whitelist OpenSea proxy contract for easy trading.
        if (isProxy(_owner, _operator)) {
            return true;
        }
        return super.isApprovedForAll(_owner, _operator);
    }

    function exists(uint256 tokenId) public view returns (bool) {
        return _exists(tokenId);
    }

    function uri(uint256 tokenId) public view returns (string memory) {
        return tokenURI(tokenId);
    }

    function setDefaultTokenURI(string memory _defaultTokenURI) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setDTokenURI: unauthorized"
        );
        require(!lockedForever, "RSC::setDTokenURI: locked");
        _setDefaultTokenURI(_defaultTokenURI);
    }

    function setCustomTokenURI(uint256 _id, string memory _customTokenURI)
        external
    {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setCTokenURI: unauthorized"
        );
        require(!lockedForever, "RSC::setCTokenURI: locked");
        _setCustomTokenURI(_id, _customTokenURI);
    }

    function setCustomCompositeTokenURIBase(
        uint256 _id,
        string memory _customCompositeTokenURIBase
    ) external {
        require(
            hasRole(COMPOSITE_CREATOR_ROLE, _msgSender()),
            "RSC::setCCTURIB: unauthorized"
        );
        _setCustomCompositeTokenURIBase(_id, _customCompositeTokenURIBase);
    }

    function setGlobalCompositeTokenURIBase(
        string memory _globalCompositeTokenURIBase
    ) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setGCTURIB: unauthorized"
        );
        _setGlobalCompositeTokenURIBase(_globalCompositeTokenURIBase);
    }

    function setContractURI(string memory contractURI) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setCURI: unauthorized"
        );
        require(!lockedForever, "RSC::setContractURI: locked");
        _setContractURI(contractURI);
    }

    function setUseCompositeTokenURI(uint256 _id, bool _useComposite) external {
        require(
            _isApprovedOrOwner(_msgSender(), _id),
            "RSC::setUseCTURI: unauthorized"
        );
        _setUseCompositeURI(_id, _useComposite);
    }

    function setProxyRegistryAddress(address _proxyRegistryAddress) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setPRAddress: unauthorized"
        );
        require(!lockedForever, "RSC::setPRegAddress: locked");
        _updateProxyRegistryAddress(_proxyRegistryAddress);
    }

    function setTransferListener(address _transferListener) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setTListener: unauthorized"
        );
        transferListener = ITransferListener(_transferListener);
    }

    function setERC2665Handler(address _erc2665Handler) external {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setERC2665H: unauthorized"
        );
        erc2665Handler = IERC2665Handler(_erc2665Handler);
    }

    function lock() external {
        require(
            hasRole(GOVERNANCE_ROLE, _msgSender()),
            "RSC::lock: unauthorized"
        );
        require(!lockedForever, "RSC::lock: already");

        lockedForever = true;

        emit Lock(totalSupply());
    }

    function setFee(address payable _feeRecipient, uint256 _feeValueBps)
        external
    {
        require(
            hasRole(OPERATOR_ROLE, _msgSender()),
            "RSC::setFee: unauthorized"
        );

        _setSecondarySaleFee(_feeRecipient, _feeValueBps);
    }

    function getTransferFee(uint256 _tokenId) external view returns (uint256) {
        if (address(erc2665Handler) != address(0)) {
            return erc2665Handler.getTransferFee(_tokenId, "");
        }

        return 0;
    }

    function getTransferFee(uint256 _tokenId, string calldata _currencySymbol)
        external
        view
        returns (uint256)
    {
        if (address(erc2665Handler) != address(0)) {
            return erc2665Handler.getTransferFee(_tokenId, _currencySymbol);
        }

        return 0;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(
            AccessControlEnumerable,
            ERC721,
            ERC721Enumerable,
            HasSecondarySaleFee,
            HasContractURI
        )
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        super._afterTokenTransfer(from, to, tokenId);

        if (address(transferListener) != address(0)) {
            try
                transferListener.onTransfer(
                    address(this),
                    tokenId,
                    from,
                    to,
                    ""
                )
            {} catch {}
        }
    }
}
